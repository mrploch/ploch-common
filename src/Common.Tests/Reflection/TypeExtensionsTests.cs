// TODO: Fix those autogenerated tests.
// using System.Diagnostics.CodeAnalysis;
// using FluentAssertions;
// using Objectivity.AutoFixture.XUnit2.AutoMoq.Attributes;
// using Xunit;
//
// namespace Ploch.Common.Reflection.Tests;
//
// [SuppressMessage("Minor Code Smell", "S2094:Classes should not be empty", Justification = "Classes here are used for testing purposes and are intentionally empty.")]
// public class TypeExtensionsTests
// {
//     public enum ExampleEnum
//     { }
//
//     [Theory]
//     // Implementing
//     [InlineData(typeof(TestClass1), typeof(IBaseInterface), true)]
//     [InlineData(typeof(TestClass1), typeof(ITestInterface1), true)]
//     [InlineData(typeof(TestClass1), typeof(ITestInterface2), true)]
//     [InlineData(typeof(TestClass2), typeof(ITestInterface1), true)]
//     [InlineData(typeof(TestClass2), typeof(ITestInterface2), true)]
//     [InlineData(typeof(ITestInterface4), typeof(ITestInterface1), true)]
//     [InlineData(typeof(ITestInterface4), typeof(ITestInterface2), true)]
//     [InlineData(typeof(TestGenericClass3<>), typeof(IGenericInterface<>), true)]
//     [InlineData(typeof(TestGenericClass3<int>), typeof(IGenericInterface<int>), true)]
//     [InlineData(typeof(TestClass2), typeof(TestClass1), true)]
//     [InlineData(typeof(TestClass4), typeof(TestGenericClass3<int>), true)]
//     // Not implementing
//     [InlineData(typeof(TestGenericClass3<int>), typeof(IGenericInterface<string>), false)]
//     [InlineData(typeof(ITestInterface4), typeof(ITestInterface4), false)]
//     [InlineData(typeof(TestClass1), typeof(ITestInterface3), false)]
//     [InlineData(typeof(ITestInterface4), typeof(ITestInterface3), false)]
//     public void IsImplementing_should_return_true_if_type_is_implementing_interface(Type type, Type baseInterface, bool result)
//     {
//         type.IsImplementing(baseInterface).Should().Be(result);
//     }
//
//     [Fact]
//     public void IsImplementing_should_return_false_if_type_is_not_implementing_interface()
//     {
//         typeof(TestClass1).IsImplementing(typeof(ITestInterface3)).Should().BeFalse();
//         typeof(ITestInterface4).IsImplementing(typeof(ITestInterface3)).Should().BeFalse();
//     }
//
//     [Theory]
//     [AutoMockData]
//     public void IsEnumerable_should_return_true_if_type_is_array(int[] array)
//     {
//         array.GetType().IsEnumerable().Should().BeTrue();
//     }
//
//     [Theory]
//     [AutoMockData]
//     public void IsEnumerable_should_return_true_if_type_is_list(List<string> list)
//     {
//         list.GetType().IsEnumerable().Should().BeTrue();
//     }
//
//     [Theory]
//     [AutoMockData]
//     public void IsEnumerable_should_return_true_if_type_is_enumerable(IEnumerable<string> list)
//     {
//         list.GetType().IsEnumerable().Should().BeTrue();
//     }
//
//     [Fact]
//     public void IsConcreteImplementation_should_return_true_for_concrete_classes()
//     {
//         // Arrange
//         var concreteType = typeof(ConcreteExampleClass);
//
//         // Act
//         var isConcrete = concreteType.IsConcreteImplementation(typeof(AbstractExampleClass));
//
//         // Assert
//         isConcrete.Should().BeTrue();
//     }
//
//     [Fact]
//     public void IsConcreteImplementation_should_return_false_for_abstract_classes()
//     {
//         // Arrange
//         var abstractType = typeof(AbstractExampleClass);
//
//         // Act
//         var isConcrete = abstractType.IsConcreteImplementation();
//
//         // Assert
//         isConcrete.Should().BeFalse();
//     }
//
//     [Fact]
//     public void IsConcreteImplementation_should_return_false_for_interfaces()
//     {
//         // Arrange
//         var interfaceType = typeof(IExampleInterface);
//
//         // Act
//         var isConcrete = interfaceType.IsConcreteImplementation();
//
//         // Assert
//         isConcrete.Should().BeFalse();
//     }
//
//     [Fact]
//     public void IsConcreteImplementation_should_return_false_for_structs()
//     {
//         // Arrange
//         var structType = typeof(ExampleStruct);
//
//         // Act
//         var isConcrete = structType.IsConcreteImplementation();
//
//         // Assert
//         isConcrete.Should().BeFalse();
//     }
//
//     [Fact]
//     public void IsConcreteImplementation_should_return_false_for_enums()
//     {
//         // Arrange
//         var enumType = typeof(ExampleEnum);
//
//         // Act
//         var isConcrete = enumType.IsConcreteImplementation();
//
//         // Assert
//         isConcrete.Should().BeFalse();
//     }
//
//     [Fact]
//     public void IsConcreteImplementation_should_return_false_for_null()
//     {
//         // Arrange
//         Type type = null;
//
//         // Act
//         var isConcrete = type.IsConcreteImplementation();
//
//         // Assert
//         isConcrete.Should().BeFalse();
//     }
//
//     public class ConcreteExampleClass : AbstractExampleClass
//     { }
//
//     public abstract class AbstractExampleClass : IExampleInterface
//     { }
//
//     public interface IExampleInterface : IBaseInterface
//     { }
//
//     public struct ExampleStruct
//     { }
//
//     private interface IBaseInterface
//     { }
//
//     private interface ITestInterface1 : IBaseInterface
//     { }
//
//     private interface ITestInterface2
//     { }
//
//     private interface ITestInterface3
//     { }
//
//     private class TestClass1 : ITestInterface1, ITestInterface2
//     { }
//
//     private interface ITestInterface4 : ITestInterface1, ITestInterface2
//     { }
//
//     private class TestClass2 : TestClass1
//     { }
//
//     private interface IGenericInterface<T>
//     { }
//
//     private class TestGenericClass3<T> : IGenericInterface<T>
//     { }
//
//     private class TestClass4 : TestGenericClass3<int>
//     { }
// }
